# 01_알고리즘 - 소개


# 02_정렬
- 특정 값을 기준으로 데이터를 순서대로 배치하는 방법
- 구현 난이도는 쉽지만, 속도는 느림
    - 버블 정렬, 삽입 정렬, 선택 정렬
- 구현 난이도는 조금 더 어렵지만, 속도는 빠름
    - 합병 정렬, 힙 정렬, 퀵 정렬, 트리 정렬
- 하이브리드 정렬
    - 팀 정렬, 블록 병합 정렬, 인트로 정렬
- 기타 정렬
    - 기수 정렬, 카운팅 정렬, 셸 정렬, 보고 정렬

## 버블 정렬
- 인접한 데이터를 비교하며 자리를 바꾸는 방식
- 알고리즘 복잡도: O(n<sup>2</sup>) = (n-1)+(n-2)+...+2+1

## 삽입 정렬(Insertion Sort)
- 앞의 데이터를 정렬 해가면서 삽입 위치를 찾아 정렬하는 방식
- 알고리즘 복잡도: O(n<sup>2</sup>)

## 선택 정렬(Selection sort)
- 최소 또는 최대 값을 찾아서 가장 앞 또는 뒤 부터 정렬하는 방식
- 알고리즘 복잡도: O(n<sup>2</sup>)

## 합병 정렬(Merge Sort)
- 배열을 계속 분항해서 길이가 1이 되도록 만들고, 인접한 부분끼리 정렬하면서 합병하는 방식
- 알고리즘 복잡도: O(nlogn)

## 힙 정렬(Heap Sort)
- 힙 자료구조 형태의 정렬 방식
- 기존 배열을 최대 힙으로 구조 변경 후 정렬 진행
- 알고리즘 복잡도: O(nlogn)

## 퀵 정렬(Quick Sort)
- 임의의 기준 값(pivot)을 정하고 그 값을 기준으로 좌우로 분할하며 정렬하는 방식
- 알고리즘 복잡도: O(n<sup>2</sup>) - 기준 값이 최소값 또는 최대값으로 지정되는 경우
- pivot 선택 방법
    - 좌측, 우측, 가운데
    - 3개의 값의 중간 값

## 트리 정렬(Tree Sort)
- 이진 탐색 트리(BST)를 만들어 정렬하는 방식
- 알고리즘 복잡도: O(nlogn)
 
# 03_이진 탐색


# 04_투 포인터


# 05_그리디 알고리즘
- 매 순간 현재 기준으로 최선의 답을 선택해 나가는 기법
    - 빠르게 근사치 계산 가능
    - 결과적으로는 최적해가 아닐 수 있음(근사치)
    - 두 가지 조건에 해당하는 경우 적용 가능
        - 탐욕적 선택 특성: 지금 선택이 다음 선택에 영향 X
        - 최적 부분 구조: 전체 문제의 최적해는 부분 문제의 최적해로 이어짐
- 예시
    - Activity Selection Problem
        - N개의 활동과 각 활동의 시작/종료 시간이 주어졌을 때, 한 사람이 최대한 많이 할 수 있는 활동의 수 구하기
            - 종료 시간 기준으로 정렬
            - 먼저 종료되는 활동 순, 겹치지 않는 순으로 선택
        - 거스름 돈(동전 개수 가장 적게)
            - 잔돈: 890
            - 동전 종류 : 10, 50, 100, 500
            - 큰 동전부터 계산

# 06_분할 정복(Divide and Conquer)
- 큰 문제를 작은 부분 문제로 나누어 해결하는 방법
    - 합병 정렬, 퀵 정렬, 이진 검색, ...
- 분할 정복 과정
    1. 문제를 하나 이상의 작은 부분들로 분할
    2. 부분들을 각각 정복
    3. 부분들의 해답을 통합하여 원래 문제의 답을 구함
- 장점
    - 문제를 나누어 처리하며 어려운 문제 해결 가능
    - 병렬 처리에 이점이 있음
- 단점
    - 메모리를 많이 사용(재귀 호출 구조)

# 07_다이나믹 프로그래밍(동적 계획법; DP)
- 큰 문제를 부분 문제로 나눈 후 답을 찾아가는 과정에서, 계산된 결과를 기록하고 재활용하며 문제의 답을 구하는 방식
- 중간 계산 결과를 기록하기 위한 메모리가 필요
- 한 번 계산한 부분을 다시 계산하지 않아 속도가 빠름
- 다른 알고리즘과의 차이점
    - 분할 정복
        - 분할 정복: 부분 문제가 중복되지 않음
        - DP: 부분 문제가 중복되어 재활용에 사용
    - 그리디 알고리즘
        - 그리디 알고리즘: 순간의 최선을 구하는 방식(근사치)
        - DP: 모든 방법 확인 후 최적해 구하는 방식
- 다이나믹 프로그래밍 방법
    - 타뷸레이션(Tabulation)
        - 상향식
        - 작은 하위 문제부터 풀면서 올라감
        - 모두 계산하면서 차례대로 진행
    - 메모이제이션(Memoization)
        - 하항식
        - 큰 문제에서 하위 문제 확인하며 진행
        - 계산이 필요한 순간 계산하며 진행
        

# 08_백트래킹


# 09_최단경로


# 10_최소 신장 트리
