# 00_좋은 코드란 무엇인가?
## 좋은 코드?
  1. 시간복잡도가 낮은 코드
  2. 공간복잡도가 낮은 코드
  3. 문서화가 잘 되어있는 코드
  4. 유지보수하기 용이한 코드
  5. 중복이 없는 코드
  6. 가독성이 높은 코드
  7. 테스트하기 쉬운 코드
  8. **value**

## 레거시 코드
- 하위 호환성 + 내가 안 짠거
- 고통을 주는 지점
    1. 내가 안짬
    2. 복잡한 이해관계(히스토리)
    3. 가독성이 떨어져 이해하기 어려움
    4. 아무튼 복잡해서 뭐하는 코드인지 파악하기 힘듬

## Software Lifecycle
1. 요구사항 분석
2. 설계
3. 구현
4. 테스트
5. 서비스 출시
6. 유지보수
   - 기능 개선
   - 정책 변경
   - 서비스 확장
   - 프로모션
7. 서비스 종료


# 01_가독성을 높이는 습관
## 이름 짓기 
- 의도를 분명히 밝혀라
- 그릇된 정보를 피하라
- 의미 있게 구분하라
- 발음/검색하기 쉬운 이름을 사용하라
- 자신의 기억력을 자랑하지 마라
- 기발한 이름을 피하라
- 한 개념에 한 단어를 사용하라
- 말장난을 하지 마라
- 해법/문제 영역에서 가져온 이름을 사용하라
- 의미 있는 맥락을 추가하라
- 불필요한 맥락을 없애라

### 상수 & 변수 (지역변수, 전역변수, 메서드 파라미터)
- 상수 / 변수 자체에 의미 담기

### 메서드 & 클래스
- 메서드와 기대하는 동작 
  - 메서드명과 다른 일을 하는 메서드 X
  - 뭘 하는지 알 수 없는 메서드 X

### 모듈 & 프로젝트
- 이미 정해져 있음

### 일정한 규칙
- prefix vs postfix
- response vs result
- DTO vs Dto vs VO
- get vs find vs search
- delete vs remove
- user<u>s</u> vs user<u>List</u>
- params vs parametere
- optional vs maybe
- ...

### 풀어서 쓰기
- nm -> name
- cd -> code
- st -> status
- ord -> order
- mbr -> member
- grp -> group

### 정리
- 이름을 지을 땐 의미 부여
- 메서드의 이름은 기대하는 동작을 명확히 서술
- 메서드는 이름과 다른 일을 하면 안 됨
- 이름을 지을 떈 일정한 규칙을 갖고 일관성을 유지
- 축약어 보다는 풀어서 쓰기


## 캡슐화
- 객체의 속성(data fields)과 행위(메서드, methods)를 하나로 묶고 실제 구현 내용 일부를 외부에 감추어 **은닉**한다. 접근 지정자를 두어 은닉의 정도를 기술하여 구현한다.
- TDA(Tell, Don't Ask) 원칙 - Martin Fowler
  - https://martinfowler.com/bliki/TellDontAsk.html
- 캡슐화로 얻을 수 있는 것
  - 데이터와 그 처리방법을 숨길 수 있음
  - 동일한 접근 가능 => 외부에 대한 영향력 줄어듬 -> 버그 포인트 줄어듬

## enum
```java
enum Color {
    private final int r;
    private final int g;
    private final int b;

    RED(255, 0, 0),
    GREEN(0, 255, 0),
    BLUE(0, 0, 255)
    ;

    public String getRgbStr() {
        return String.format("#%x%x%x", r, g, b)
    }
}

```
- 장점
  - 상수 대비 가독성이 뛰어남
  - enum 기본 함수 제공(name, ordinal, values..)
  - IDE 또움이 뛰어남(검색, 타입 체크 등)
  - final => 인스턴스 변수가 1개가 있음을 보장
  - 상수 확장성(필드 및 메서드 등)
- 주의사항
  - 배포 시 문제가 발생할 수 있음
  - 다른 시스템과 연계 시 문제가 발생할 수 있음


## null
- null이란
  - 아무런 값도 존재하지 않는 상태
  - NullPointerException 발생시킴
  - 매번 회피 로직을 넣어야 안전
  - 가끔은 전혀 의도하지 않은 방법으로 동작

## null Handling
### 단정문(Assertion)
- 별 의미 없음. 쓰지말자.

### Objects (JDK 1.8+)
- Boolean Check
  - boolean isNull(Object obj);
  - boolean nonNull(Object obj);
- Fail Fast  
  - T requireNonNull(T obj)
  - T requireNonNull(T obj, String message)
  - T requireNonNull(T obj, Supplier\<String\> messageSupplier)

### null 표현하기 - 타입
- Primitive type
  - boolean
  - char
  - int
  - long
  - float
  - double
  - ...
- Reference type
  - 기본 타입의 Wrapper class

### etc
1. 선언과 동시에 초기화
2. 다양한 유틸 클래스 활용(스프링, 구아바, 아파치 커먼즈...)
3. null 파라미터가 존재한다면, 오버로딩으로 교체
4. List<T> 일 땐 빈 리스트 활용
5. 상황에 따라 Null Object Pattern 활
6. 최대한 직접 핸들링 지양

### 정리
1. 선언과 동시에 초기화가 최고(null 발생 X)
2. Assertion 문은 되도록 쓰지 말자
3. Null은 되도록 직접 핸들링 하지 말자
4. JDK 1.8+ 에서 제공하는 유틸 적극 활용(Objects)
5. Primitive type, Reference type으로 nullable 여부 나타내기
6. List는 null 대신 emptyList()
7. null을 대체할 스테틱 객체 리턴(null object pattern)

## Optional (JDK 1.8+)
- 장점
  - Null을 직접 핸들링하지 않음
  - Null 여부를 타입만으로 나타낼 수 있음
  - 체이닝을 통한 중간 및 종단 처리
- 내부구현
  - static factory methods
    - ```empty()```
    - ```of(T value)```
    - ```ofNullable(T value)```
  - 종단 연산
    - ```boolean isPresent()``` : null 여부 판단
    - ```void ifPresent(Consumer<? super T> consumer)``` : value가 null이 아닐 때 consumer에 value 전달
  - 값 가져오는 함수
    - ```T get()``` : null일 때 NosuchElementException 발생
    - ```T orElse(T other)``` : optional이 null일 때 other(default) 리턴
    - ```T orElseGet(Supplier<? extends T> other)``` : optional이 null인 경우 other의 값 리턴(해당 other 값이 필요할 때만 get 수행)
    - ```<X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X``` : null인 경우 넘겨준 exception 터트림
  - 중간 연산자
    - ```Optional<T> filter(Predicate<? super T> predicate)``` : predicate가 true일 때만 return하고 null이면 empty() 리턴
    - ```Optional<U> map(Function<? super T, ? extends U> mapper)``` : 값이 없으면 empty() 리턴, 값이 있으면 내부 값을 컨버팅 후, Optional(ofNaullable)로 감싸서 리턴
    - ``` Optional<U> flatMap(function<? super T, Optional<U>> mapper)``` : requireNonNull로 감싸서 리턴

### Oracle Docs
- "결과 없음"이 가능하고
- null 반환 시 에러가 발생할 수 있는 곳의 메서드 리턴 값
- null 대신 Optional.empty()

### 사용하기
- 값이 없을 수도 있을 경우 Optional 리턴
  - null 리턴 XX
- 필드에 Optional은 지양
  1. Optional은 함수의 반환을 목적으로 만들어짐
  2. Serializable 구현하지 않아 직렬화되지 않음
     - 다른 시스템에 전달할 수 없음
  3. Optional.empty()를 빠뜨릴 확률이 높음(휴먼 에러)

### Optional과 Collection
- 비어있을 컬렉션을 표현할 땐 Collection.emptyList() 사용하기
- 컬렉션 요소에 Optional은 절대 금지
- Optional을 파라미터로 넘기지 않기
- Optional 값을 가져올 때 get()은 되도록 지양하기

### 정리
- 결과가 없을 땐 null 대신 Optional.empty()
- 어떠한 일이 있어도 Optional.empty()는 null로 리턴 X
- 중간/종단 메서드로 안전하게 처리 가능
- 기존 시스템이 null을 리턴하면 Optional.ofNullable로 감싸서 사용
  - 많이 쓰면 오히려 가독성을 해칠 수 있음
- Optional은 함수의 반환 타입을 위해 만들어졌기 때문에 필드에 써야할 땐 한 번 더 고민해보기
- Collection은 Optional 대신 비어있는 Collection 사용(emptyList, emptyMap,..)

## Side Effect 줄이기

## 심플하게 구성하기

## 심미적 방법들

## 주석

## Exception Handling

## Test Code

# 02_의존성 다루기

# 03_디자인 패턴 살펴보기